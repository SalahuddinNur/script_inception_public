
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>GWL.GWL_parser &#8212; script_inception_public  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">script_inception_public  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for GWL.GWL_parser</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceil</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">utilities.common</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">utilities</span> <span class="k">import</span> <span class="n">TransformationMatrix</span>

<span class="c1"># TODO: get voxelsize in any direction based on a 3D ellipsoid...</span>

<span class="c1"># TODO: Somehow get voxel size based on scanspeed/power/dwelltime/defocusfactor/etc</span>
<span class="n">DEFAULT_VOXEL_WIDTH</span> <span class="o">=</span> <span class="mf">0.100</span> <span class="c1"># in mum</span>
<span class="n">DEFAULT_VOXEL_HEIGHT</span> <span class="o">=</span> <span class="mf">0.200</span> <span class="c1"># in mum</span>
<span class="n">DEFAULT_OVERLAP_HORIZONTAL</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">DEFAULT_OVERLAP_VERTICAL</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="c1"># TODO: Start creating external GWL object classes like blocks, spheres, etc which can be added to a main GWL object (similar to BFDTD)</span>

<span class="c1"># TODO: Add options or new functions to allow other desired systems like extremity points always separated by length, or always fill so that it touches the extremities, etc</span>
<span class="c1"># TODO: Document with pictures. Check how to do that with doxygen or similar.</span>
<span class="c1"># TODO: Start generating code documentation.</span>
<div class="viewcode-block" id="calculateNvoxelsAndInterVoxelDistance"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.calculateNvoxelsAndInterVoxelDistance">[docs]</a><span class="k">def</span> <span class="nf">calculateNvoxelsAndInterVoxelDistance</span><span class="p">(</span><span class="n">Length</span><span class="p">,</span> <span class="n">Voxelsize</span><span class="p">,</span> <span class="n">Overlap</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Calulates the number of voxels and the distance between them so that they fit into length &quot;Length&quot; with an overlap &quot;Overlap&quot;, i.e. so that:</span>
<span class="sd">  </span>
<span class="sd">  * InterVoxelDistance = (1-Overlap)*Voxelsize</span>
<span class="sd">  * (Nvoxels-1)*InterVoxelDistance + Voxelsize &lt;= Length</span>
<span class="sd">  &#39;&#39;&#39;</span>

  <span class="k">if</span> <span class="n">Overlap</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">Overlap</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;ERROR: Invalid Overlap = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Overlap</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">Voxelsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;ERROR: Invalid Voxelsize = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Voxelsize</span><span class="p">))</span>

  <span class="n">InterVoxelDistance</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Overlap</span><span class="p">)</span><span class="o">*</span><span class="n">Voxelsize</span>
  <span class="c1">#Nvoxels = math.floor( ((Length-Voxelsize)/InterVoxelDistance) + 1 )</span>

  <span class="c1"># Same formula as above, but seems to work better in some cases (gave expected floor(3.0)=3 instead of floor(2.999...)=2 in one case for instance...)</span>
  <span class="n">Nvoxels</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">((</span><span class="n">Length</span><span class="o">-</span><span class="n">Overlap</span><span class="o">*</span><span class="n">Voxelsize</span><span class="p">)</span><span class="o">/</span><span class="n">InterVoxelDistance</span><span class="p">)</span> <span class="p">)</span>

  <span class="k">if</span><span class="p">(</span><span class="n">Nvoxels</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">Nvoxels</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;WARNING: Voxel too big for specified length.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">Nvoxels</span><span class="p">,</span> <span class="n">InterVoxelDistance</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject">[docs]</a><span class="k">class</span> <span class="nc">GWLobject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39;This is the main class used to read/write/create GWL files for the Nanoscribe.</span>
<span class="sd">  </span>
<span class="sd">  Basic usage example::</span>
<span class="sd">  </span>
<span class="sd">    #!/usr/bin/env python3</span>
<span class="sd">    from GWL.GWL_parser import GWLobject</span>
<span class="sd">    </span>
<span class="sd">    obj = GWLobject()</span>
<span class="sd">    obj.addVoxel([10, 20, 30, 40])</span>
<span class="sd">    obj.addVoxel([11, 21, 31, 41])</span>
<span class="sd">    obj.addVoxel([12, 22, 32, 42])</span>
<span class="sd">    obj.startNewVoxelSequence()</span>
<span class="sd">    obj.addVoxel([5, 6, 7])</span>
<span class="sd">    obj.addVoxel([8, 9, 10])</span>
<span class="sd">    obj.addVoxel([5, 6, 7])</span>
<span class="sd">    obj.addVoxel([8, 9, 10])</span>
<span class="sd">    obj.startNewVoxelSequence()</span>
<span class="sd">    obj.addVoxel([5, 6, 7])</span>
<span class="sd">    obj.addVoxel([8, 9, 10])</span>
<span class="sd">    obj.writeGWL(&#39;foo.gwl&#39;)</span>
<span class="sd">    </span>
<span class="sd">  This should produce a file named &#39;foo.gwl&#39; containing::</span>
<span class="sd">  </span>
<span class="sd">    10.000  20.000  30.000  40.000</span>
<span class="sd">    11.000  21.000  31.000  41.000</span>
<span class="sd">    12.000  22.000  32.000  42.000</span>
<span class="sd">    Write</span>
<span class="sd">    5.000   6.000   7.000</span>
<span class="sd">    8.000   9.000   10.000</span>
<span class="sd">    5.000   6.000   7.000</span>
<span class="sd">    8.000   9.000   10.000</span>
<span class="sd">    Write</span>
<span class="sd">    5.000   6.000   7.000</span>
<span class="sd">    8.000   9.000   10.000</span>
<span class="sd">    Write</span>

<span class="sd">  **Attributes**:</span>
<span class="sd">  </span>
<span class="sd">  * Writing settings:</span>
<span class="sd">    </span>
<span class="sd">  :ivar set_lower_to_origin: If true, offsets the structure so that the lower corner is at (0,0,0). Defaults to False.</span>
<span class="sd">  :ivar write_power: Write out power values. Defaults to False.</span>

<span class="sd">  * Power compensation settings (set the slope to zero for a constant power):</span>
<span class="sd">    </span>
<span class="sd">  :ivar PC_laser_power_at_z0:      PC_laser_power_at_z0. Defaults to 100.</span>
<span class="sd">  :ivar PC_slope:                  PC_slope (set the slope to zero for a constant power). Defaults to 0.</span>
<span class="sd">  :ivar PC_interfaceAt:            PC_interfaceAt. Defaults to 0.</span>
<span class="sd">  :ivar PC_float_height:           PC_float_height. Defaults to 0.</span>
<span class="sd">  :ivar PC_bool_InverseWriting:    PC_bool_InverseWriting. Defaults to False.</span>
<span class="sd">  :ivar PC_bool_LaserPowerCommand: PC_bool_LaserPowerCommand.  Defaults to False.</span>
<span class="sd">  </span>
<span class="sd">  .. note:: They currently only have an effect when :py:func:`writeGWLWithPowerCompensation` is used. Not when :py:func:`writeGWL` is used.</span>

<span class="sd">  **Inner workings**:</span>
<span class="sd">  </span>
<span class="sd">    The voxels are stored in **GWL_voxels**.</span>
<span class="sd">    This is the most important attribute.</span>
<span class="sd">    It stores all voxels in a list of the form [ write_sequence_0, write_sequence_1, ... ] where:</span>
<span class="sd">    </span>
<span class="sd">    * the write_sequence_i are of the form [voxel_0, voxel_1, ...]</span>
<span class="sd">    * the voxel_i of the form [x, y, z] or [x, y, z, power].</span>

<span class="sd">  .. todo:: Needs to be rewritten to support new GWL commands, but also non-voxel/Write commands in general...</span>
<span class="sd">  .. todo:: Document all attributes using ivar and #:</span>
<span class="sd">  .. todo:: Use vtkpolydata or similar for paraview visualization, boolean operations, etc</span>
<span class="sd">  .. todo:: Maybe add a vtk-like Update() function which would do all the things which are currently done during writing? Writing would then call update before doing a very basic write call. Issues: Speed... Doing everything in VTK, using filters, etc, might speed up the process.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Constructor&#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#: &quot;List of lists of voxels&quot;.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">FindInterfaceAt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stage_position</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LineNumber</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LineDistance</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PowerScaling</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LaserPower</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ScanSpeed</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Repeat</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">path_substitutes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">writingDistanceInMum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">DwellTime</span> <span class="o">=</span> <span class="mi">200</span> <span class="c1">#: in ms = 1e-3 seconds</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">minDistanceBetweenLines</span> <span class="o">=</span> <span class="mi">1000</span> <span class="c1">#: shortest distance from end of one line to start of next one</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">maxDistanceBetweenLines</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#: maximum acceptable distance from end of one line to start of next one</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LastVoxel</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">LastVoxelSet</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">out_of_range</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">overlap_horizontal</span> <span class="o">=</span> <span class="n">DEFAULT_OVERLAP_HORIZONTAL</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">overlap_vertical</span> <span class="o">=</span> <span class="n">DEFAULT_OVERLAP_VERTICAL</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">voxel_width_mum</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_WIDTH</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">voxel_height_mum</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_HEIGHT</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#: Minimum of X, Y, Z and power. Updated with updateLimits() and retrievable with getLimits().</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#: Maximum of X, Y, Z and power. Updated with updateLimits() and retrievable with getLimits().</span>

    <span class="c1"># writing settings</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_lower_to_origin</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#: If true, offsets the structure so that the lower corner is at (0,0,0)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">write_power</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#: write out power values</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reverse_line_order_on_write</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#: If True, the order of the lines will be reversed **during writing**. See also: :py:func:`reverse`</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reverse_voxel_order_per_line_on_write</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#: If True, the order of the voxels in each line will be reversed **during writing**. See also: :py:func:`reverse`</span>

    <span class="c1"># power compensation settings </span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_laser_power_at_z0</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1">#: PC_laser_power_at_z0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_slope</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#: PC_slope (set the slope to zero for a constant power)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_interfaceAt</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#: PC_interfaceAt</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_float_height</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#: PC_float_height</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_bool_InverseWriting</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#: PC_bool_InverseWriting</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_bool_LaserPowerCommand</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1">#: PC_bool_LaserPowerCommand</span>
  
<div class="viewcode-block" id="GWLobject.setVoxels"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.setVoxels">[docs]</a>  <span class="k">def</span> <span class="nf">setVoxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Set the voxels as a list of the form [[v0,v1,...], [vA,vB,...], ...] where v* are voxel coordinates, i.e. [X,Y,Z] or [X,Y,Z,power]. &#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span> <span class="o">=</span> <span class="n">L</span>
    <span class="k">return</span></div>
    
<div class="viewcode-block" id="GWLobject.getVoxels"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getVoxels">[docs]</a>  <span class="k">def</span> <span class="nf">getVoxels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Returns a list of the voxels in the form specified in :py:func:`setVoxels`. &#39;&#39;&#39;</span>
    <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">)</span></div>
  
<div class="viewcode-block" id="GWLobject.appendVoxels"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.appendVoxels">[docs]</a>  <span class="k">def</span> <span class="nf">appendVoxels</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; &quot;append&quot; a &quot;line of voxels&quot; &#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GWLobject.extendVoxels"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.extendVoxels">[docs]</a>  <span class="k">def</span> <span class="nf">extendVoxels</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; &quot;extend&quot; with multiple &quot;lines of voxels&quot; &#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">L</span><span class="p">)</span></div>
  
<div class="viewcode-block" id="GWLobject.reverse"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.reverse">[docs]</a>  <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse_line_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reverse_voxel_order_per_line</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Reverse the order of the voxels. Unlike  :py:attr:`reverse_line_order_on_write` and :py:attr:`reverse_voxel_order_per_line_on_write`, this applies directly.</span>
<span class="sd">    </span>
<span class="sd">    :param reverse_line_order: If True, the order of the lines will be reversed, i.e.::</span>
<span class="sd">    </span>
<span class="sd">        voxel0</span>
<span class="sd">        voxel1</span>
<span class="sd">        voxel2</span>
<span class="sd">        Write</span>
<span class="sd">        voxel3</span>
<span class="sd">        voxel4</span>
<span class="sd">        voxel5</span>
<span class="sd">        Write</span>
<span class="sd">      </span>
<span class="sd">      becomes::</span>

<span class="sd">        voxel3</span>
<span class="sd">        voxel4</span>
<span class="sd">        voxel5</span>
<span class="sd">        Write</span>
<span class="sd">        voxel0</span>
<span class="sd">        voxel1</span>
<span class="sd">        voxel2</span>
<span class="sd">        Write</span>

<span class="sd">    :param reverse_voxel_order_per_line: If True, the order of the voxels in each line will be reversed, i.e.::</span>
<span class="sd">    </span>
<span class="sd">        voxel0</span>
<span class="sd">        voxel1</span>
<span class="sd">        voxel2</span>
<span class="sd">        Write</span>
<span class="sd">        voxel3</span>
<span class="sd">        voxel4</span>
<span class="sd">        voxel5</span>
<span class="sd">        Write</span>
<span class="sd">      </span>
<span class="sd">      becomes::</span>

<span class="sd">        voxel2</span>
<span class="sd">        voxel1</span>
<span class="sd">        voxel0</span>
<span class="sd">        Write</span>
<span class="sd">        voxel5</span>
<span class="sd">        voxel4</span>
<span class="sd">        voxel3</span>
<span class="sd">        Write</span>
<span class="sd">    </span>
<span class="sd">    :return: None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">reverse_line_order</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">reverse_voxel_order_per_line</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
        <span class="n">write_sequence</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    
    <span class="k">return</span></div>
  
<div class="viewcode-block" id="GWLobject.add_arguments"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.add_arguments">[docs]</a>  <span class="k">def</span> <span class="nf">add_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Adds GWLobject related arguments to the given *parser* (an argparse.ArgumentParser instance).</span>
<span class="sd">    </span>
<span class="sd">    See also: :py:func:`setAttributesFromParsedOptions`</span>
<span class="sd">    </span>
<span class="sd">    .. todo:: Make argparseui create something in the interface to separate groups.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">group_WritingSettings</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">&#39;GWL writing settings&#39;</span><span class="p">)</span>
    <span class="n">group_WritingSettings</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--set-lower-to-origin&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;offset structure so that its &quot;lower corner&quot; is moved to the (0,0,0) coordinates. This will make all coordinates positive.&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">)</span>
    <span class="n">group_WritingSettings</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--write-power&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Write power values using the power compensation (PC) parameters.&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">)</span>
    <span class="n">group_WritingSettings</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--reverse_line_order_on_write&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;reverse line order on write&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">)</span>
    <span class="n">group_WritingSettings</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--reverse_voxel_order_per_line_on_write&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;reverse voxel order per line on write&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">)</span>

    <span class="n">group_PowerCompensation</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">&#39;GWL power compensation&#39;</span><span class="p">,</span> <span class="s1">&#39;LP(Z) = (1+K*(Z-interfaceAt))*LP(0) if bool_InverseWriting=False or LP(Z) = (1+K*((H-Z)+interfaceAt))*LP(0) if bool_InverseWriting=True&#39;</span><span class="p">)</span> <span class="c1"># TODO: nicely formatted help/description?</span>
    <span class="n">group_PowerCompensation</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--PC_laser_power_at_z0&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;PC: laser power at z0&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">group_PowerCompensation</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--PC_slope&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;PC: power compensation slope&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">group_PowerCompensation</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--PC_interfaceAt&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;PC: interface position&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">group_PowerCompensation</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--PC_bool_InverseWriting&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;PC: To write a file designed for use with the InvertZAxis command&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">group_PowerCompensation</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--PC_float_height&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;PC: &quot;substrate height&quot;, in practice just a value added to the interfaceAt value&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">group_PowerCompensation</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--PC_bool_LaserPowerCommand&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;PC: Use the LaserPower command instead of a 4th coordinate for power.&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.get_argument_parser"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.get_argument_parser">[docs]</a>  <span class="k">def</span> <span class="nf">get_argument_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fromfile_prefix_chars</span><span class="o">=</span><span class="s1">&#39;@&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-d&#39;</span><span class="p">,</span><span class="s1">&#39;--outdir&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;outdir&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">(),</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;output directory&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-b&#39;</span><span class="p">,</span><span class="s1">&#39;--basename&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;basename&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;output basename&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span></div>

<div class="viewcode-block" id="GWLobject.setAttributesFromParsedOptions"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.setAttributesFromParsedOptions">[docs]</a>  <span class="k">def</span> <span class="nf">setAttributesFromParsedOptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sets the object&#39;s attributes based on the ones from the *options* object (usually an argparse.ArgumentParser instance).</span>
<span class="sd">    </span>
<span class="sd">    See also: :py:func:`add_arguments`</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_lower_to_origin</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">set_lower_to_origin</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">write_power</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">write_power</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reverse_line_order_on_write</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">reverse_line_order_on_write</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reverse_voxel_order_per_line_on_write</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">reverse_voxel_order_per_line_on_write</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_laser_power_at_z0</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">PC_laser_power_at_z0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_slope</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">PC_slope</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_interfaceAt</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">PC_interfaceAt</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_bool_InverseWriting</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">PC_bool_InverseWriting</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_float_height</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">PC_float_height</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PC_bool_LaserPowerCommand</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">PC_bool_LaserPowerCommand</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.getMinDistanceBetweenVoxels"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getMinDistanceBetweenVoxels">[docs]</a>  <span class="k">def</span> <span class="nf">getMinDistanceBetweenVoxels</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    .. todo:: finish implementing...</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.updateLimits"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.updateLimits">[docs]</a>  <span class="k">def</span> <span class="nf">updateLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Updates the PositionMinimum and PositionMaximum attributes.</span>

<span class="sd">    See also getLimits().</span>
<span class="sd">    </span>
<span class="sd">    :return: (PositionMinimum, PositionMaximum) where PositionMinimum and PositionMaximum are lists of size 4 containing [Xmin, Ymin, Zmin, Pmin] and [Xmax, Ymax, Zmax, Pmax] respectively.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">first</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">voxel</span> <span class="ow">in</span> <span class="n">write_sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.getLimits"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getLimits">[docs]</a>  <span class="k">def</span> <span class="nf">getLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_limits</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; This function returns the minimum and maximum x,y,z coordinates.</span>

<span class="sd">    To optimize speed, it only returns the currently stored limits, which should be computed while adding voxels.</span>
<span class="sd">    To update the limits, call updateLimits().</span>

<span class="sd">    :param bool update_limits: If true, updateLimits() will be called.</span>

<span class="sd">    :return: (PositionMinimum, PositionMaximum) where PositionMinimum and PositionMaximum are lists of size 4 containing [Xmin, Ymin, Zmin, Pmin] and [Xmax, Ymax, Zmax, Pmax] respectively.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">update_limits</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">updateLimits</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GWLobject.getMeshData"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getMeshData">[docs]</a>  <span class="k">def</span> <span class="nf">getMeshData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">verts_loc</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">last_voxel_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
      <span class="n">local_vertex_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">for</span> <span class="n">voxel</span> <span class="ow">in</span> <span class="n">write_sequence</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">voxel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">voxel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">voxel</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">verts_loc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1">#edges.append(range(last_voxel_index, last_voxel_index + len(write_sequence)))</span>
        <span class="c1">#edges.append(list(range(last_voxel_index, last_voxel_index + len(write_sequence))))</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last_voxel_index</span><span class="p">,</span> <span class="n">last_voxel_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">last_voxel_index</span> <span class="o">=</span> <span class="n">last_voxel_index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span>
    <span class="k">return</span><span class="p">((</span><span class="n">verts_loc</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">faces</span><span class="p">))</span></div>

  <span class="c1"># TODO: maybe create an iterator for voxels, to make operations on all voxels as easy as for v in voxels: ...</span>
<div class="viewcode-block" id="GWLobject.applyOffset"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.applyOffset">[docs]</a>  <span class="k">def</span> <span class="nf">applyOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">voxel</span> <span class="ow">in</span> <span class="n">write_sequence</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="p">)):</span>
          <span class="c1"># TODO: URGENT/EASY: check that this works correctly for when voxel and offset don&#39;t have the same length...</span>
          <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">):</span>
            <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.getPower"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getPower">[docs]</a>  <span class="k">def</span> <span class="nf">getPower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">PC_laser_power_at_z0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PC_slope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PC_interfaceAt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PC_bool_InverseWriting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PC_float_height</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;calculate power for a given z position&#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">PC_laser_power_at_z0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PC_laser_power_at_z0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PC_laser_power_at_z0</span>
    <span class="k">if</span> <span class="n">PC_slope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PC_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PC_slope</span>
    <span class="k">if</span> <span class="n">PC_interfaceAt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PC_interfaceAt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PC_interfaceAt</span>
    <span class="k">if</span> <span class="n">PC_bool_InverseWriting</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PC_bool_InverseWriting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PC_bool_InverseWriting</span>
    <span class="k">if</span> <span class="n">PC_float_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PC_float_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PC_float_height</span>
    
    <span class="k">if</span> <span class="n">PC_bool_InverseWriting</span><span class="p">:</span>
      <span class="n">power</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">PC_slope</span><span class="o">*</span><span class="p">((</span><span class="n">PC_float_height</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">PC_interfaceAt</span><span class="p">))</span> <span class="o">*</span> <span class="n">PC_laser_power_at_z0</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">power</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">PC_slope</span><span class="o">*</span><span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">PC_interfaceAt</span><span class="p">))</span> <span class="o">*</span> <span class="n">PC_laser_power_at_z0</span>
    
    <span class="k">if</span> <span class="n">power</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">power</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">power</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">:</span> <span class="n">power</span><span class="o">=</span><span class="mi">100</span>
    
    <span class="k">return</span> <span class="n">power</span>    </div>

<div class="viewcode-block" id="GWLobject.addPowerCompensation"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addPowerCompensation">[docs]</a>  <span class="k">def</span> <span class="nf">addPowerCompensation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laser_power_at_z0</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">interfaceAt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bool_InverseWriting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">float_height</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Add a 4th power component to voxels based on the formula:</span>
<span class="sd">    </span>
<span class="sd">    * LP(Z) = (1+K*(Z-interfaceAt))*LP(0) if bool_InverseWriting=False</span>
<span class="sd">    * LP(Z) = (1+K*((H-Z)+interfaceAt))*LP(0) if bool_InverseWriting=True</span>
<span class="sd">    </span>
<span class="sd">    .. todo:: This function loops through all voxels again. It might be worth creating an addVoxel() function, so that any other functions creating the voxel lists directly add the power compensation as well.</span>
<span class="sd">    .. todo:: use in export GWL script (requires following TODO done first)</span>
<span class="sd">    .. todo:: Add option to use LaserPower command instead of 4th power voxel coordinate. Requires changing the way GWL info is stored. (or separate writeGWL function)</span>
<span class="sd">    .. todo:: Document this properly with an easy to understand image...</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">write_sequence_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">)):</span>
      <span class="n">write_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">[</span><span class="n">write_sequence_idx</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">voxel_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)):</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">write_sequence</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">]</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
          <span class="c1">#voxel[:] = numpy.append(voxel,0)</span>
          <span class="n">voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># calculate power for current voxel</span>
        <span class="n">voxel</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPower</span><span class="p">(</span><span class="n">voxel</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">PC_laser_power_at_z0</span><span class="o">=</span><span class="n">laser_power_at_z0</span><span class="p">,</span> <span class="n">PC_slope</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">PC_interfaceAt</span><span class="o">=</span><span class="n">interfaceAt</span><span class="p">,</span> <span class="n">PC_bool_InverseWriting</span><span class="o">=</span><span class="n">bool_InverseWriting</span><span class="p">,</span> <span class="n">PC_float_height</span><span class="o">=</span><span class="n">float_height</span><span class="p">)</span>
        
        <span class="n">write_sequence</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">[</span><span class="n">write_sequence_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">write_sequence</span>

    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.getLastVoxel"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getLastVoxel">[docs]</a>  <span class="k">def</span> <span class="nf">getLastVoxel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">voxel</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">)):</span>
        <span class="n">write_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">voxel</span> <span class="o">=</span> <span class="n">write_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">voxel</span><span class="p">,</span><span class="n">found</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.getNvoxels"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.getNvoxels">[docs]</a>  <span class="k">def</span> <span class="nf">getNvoxels</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ok&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.clear"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.clear">[docs]</a>  <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="GWLobject.addLine"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addLine">[docs]</a>  <span class="k">def</span> <span class="nf">addLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">power</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">P1</span><span class="p">,</span><span class="n">P2</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span></div>

  <span class="c1"># HACK: quick hack to create &quot;flat lines&quot;</span>
<div class="viewcode-block" id="GWLobject.addFlatLine"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addFlatLine">[docs]</a>  <span class="k">def</span> <span class="nf">addFlatLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">line_distance</span><span class="p">,</span> <span class="n">line_number</span><span class="p">,</span> <span class="n">power</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#print(&#39;===============AD&#39;,P1)</span>
    <span class="n">P1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
    <span class="c1">#print(&#39;===============BD&#39;,P1)</span>
    <span class="n">P2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">P2</span> <span class="o">-</span> <span class="n">P1</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">line_distance</span> <span class="o">*</span> <span class="p">(</span><span class="n">line_number</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">delta_list</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">line_number</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">line_number</span><span class="p">):</span>
      <span class="n">A</span> <span class="o">=</span> <span class="n">P1</span> <span class="o">+</span> <span class="n">delta_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span>
      <span class="n">B</span> <span class="o">=</span> <span class="n">P2</span> <span class="o">+</span> <span class="n">delta_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">v</span>
      <span class="c1">#print(&#39;flatline: &#39;,(A,B))</span>

      <span class="c1">#koko = &#39;ROFL===D: &#39;</span>
      <span class="c1">#print(koko+&#39;{} {} {}&#39;.format(A[0],A[1],A[2]))</span>
      <span class="c1">#print(koko+&#39;{} {} {}&#39;.format(B[0],B[1],B[2]))</span>
      <span class="c1">#print(koko+&#39;Write&#39;)</span>

      <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">]</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.addLineCylinder"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addLineCylinder">[docs]</a>  <span class="k">def</span> <span class="nf">addLineCylinder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">inner_radius</span><span class="p">,</span> <span class="n">outer_radius</span><span class="p">,</span> <span class="n">PointDistance_r</span><span class="p">,</span> <span class="n">PointDistance_theta</span><span class="p">):</span>
    <span class="c1"># prepare some variables</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span> <span class="c1"># vector to rotate</span>
    <span class="c1">#print((&#39;v=&#39;,v))</span>
    <span class="n">centro</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">+</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P1</span><span class="p">))</span> <span class="c1"># center of LineCylinder</span>
    <span class="c1">#print((&#39;centro=&#39;,centro))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># direction of standard TubeWithVerticalLines</span>
    <span class="c1">#print((&#39;u=&#39;,u))</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="c1"># angle by which to rotate</span>
    <span class="c1">#print((&#39;theta=&#39;,theta))</span>

    <span class="n">rotation_axis</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="c1"># axis around which to rotate</span>
    <span class="c1">#print((&#39;rotation_axis=&#39;,rotation_axis))</span>

    <span class="n">height</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="c1">#print((&#39;height=&#39;,height))</span>

    <span class="c1"># build a basis from the P1-P2 direction</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">Orthogonal</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

    <span class="c1">#print((&#39;i=&#39;,i))</span>
    <span class="c1">#print((&#39;j=&#39;,j))</span>
    <span class="c1">#print((&#39;k=&#39;,k))</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1">#print((&#39;i=&#39;,i))</span>
    <span class="c1">#print((&#39;j=&#39;,j))</span>
    <span class="c1">#print((&#39;k=&#39;,k))</span>

    <span class="c1"># transformation matrix from (x,y,z) into (i,j,k)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]))</span>
    <span class="c1">#print(P)</span>
    <span class="c1">#print(P.T)</span>
    <span class="c1">#print(P*P.T)</span>

    <span class="c1"># create a vertical tube and rotate it</span>
    <span class="n">tube</span> <span class="o">=</span> <span class="n">GWLobject</span><span class="p">()</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tube</span><span class="o">.</span><span class="n">addTubeWithVerticalLines</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inner_radius</span><span class="p">,</span> <span class="n">outer_radius</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">PointDistance_r</span><span class="p">,</span> <span class="n">PointDistance_theta</span><span class="p">,</span> <span class="n">downwardWriting</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#print((&#39;tube.GWL_voxels=&#39;,tube.GWL_voxels))</span>
    <span class="c1">#tube.writeGWL(&#39;test.gwl&#39;)</span>

    <span class="c1">#print(P)</span>
    <span class="c1">#print((&#39;centro=&#39;,centro))</span>
    <span class="n">tube</span><span class="o">.</span><span class="n">applyTransformationMatrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">centro</span><span class="p">)</span>
    <span class="c1">#print((&#39;tube.GWL_voxels=&#39;,tube.GWL_voxels))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">addGWLobject</span><span class="p">(</span><span class="n">tube</span><span class="p">)</span>


    <span class="c1">## prepare some variables</span>
    <span class="c1">#v = numpy.array(P2)-numpy.array(P1) # vector to rotate</span>
    <span class="c1">#centro = 0.5*(numpy.array(P2)+numpy.array(P1)) # center of LineCylinder</span>
    <span class="c1">#u = numpy.array([0,0,1]) # direction of standard TubeWithVerticalLines</span>
    <span class="c1">#theta = Angle(u,v) # angle by which to rotate</span>
    <span class="c1">#rotation_axis = numpy.cross(u,v) # axis around which to rotate</span>
    <span class="c1">#height = numpy.linalg.norm(v)</span>

    <span class="c1">## build a basis from the P1-P2 direction</span>
    <span class="c1">#i = v</span>
    <span class="c1">#j = Orthogonal(i)</span>
    <span class="c1">#k = numpy.cross(i,j)</span>

    <span class="c1">#i = i/numpy.linalg.norm(i)</span>
    <span class="c1">#j = j/numpy.linalg.norm(j)</span>
    <span class="c1">#k = k/numpy.linalg.norm(k)</span>

    <span class="c1">## transformation matrix from (x,y,z) into (i,j,k)</span>
    <span class="c1">#P = numpy.transpose(numpy.matrix([i,j,k]))</span>
    <span class="c1">#print(P)</span>
    <span class="c1">#print(P.T)</span>
    <span class="c1">#print(P*P.T)</span>

    <span class="c1">## create a vertical tube and rotate it</span>
    <span class="c1">#tube = GWLobject()</span>
    <span class="c1">#tube.addTubeWithVerticalLines(centro, inner_radius, outer_radius, height, power, PointDistance_r, PointDistance_theta, downwardWriting=False)</span>
    <span class="c1">#tube.applyTransformationMatrix(P.getI(), centro)</span>
    <span class="c1">#self.addGWLobject(tube)</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.addGWLobject"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addGWLobject">[docs]</a>  <span class="k">def</span> <span class="nf">addGWLobject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">GWL_voxels</span></div>
    <span class="c1">#for write_sequence in tube.GWL_voxels:</span>
          <span class="c1">#self.GWL_voxels.append(write_sequence)</span>

      <span class="c1">#for voxel in write_sequence:</span>
        <span class="c1">#for i in range(len(voxel)):</span>
          <span class="c1">#value = voxel[i] + writingOffset[i]</span>
          <span class="c1">#if i!=3: #coordinates</span>
            <span class="c1">#file_object.write( str( &quot;%.3f&quot; % (value) ) )</span>
          <span class="c1">#else: #power</span>
            <span class="c1">#if 0&lt;=value and value&lt;=100:</span>
              <span class="c1">#file_object.write( str( &quot;%.3f&quot; % (value) ) )</span>
          <span class="c1">## add tab or line ending</span>
          <span class="c1">#if i&lt;len(voxel)-1:</span>
            <span class="c1">#file_object.write(&#39;\t&#39;)</span>
          <span class="c1">#else:</span>
            <span class="c1">#file_object.write(&#39;\n&#39;)</span>


      <span class="c1">#self.addWrite()</span>

    <span class="c1">#for write_sequence in obj.GWL_voxels:</span>
      <span class="c1">#for voxel in write_sequence:</span>
        <span class="c1">#self.add</span>

        <span class="c1">#voxel = write_sequence[i]</span>
        <span class="c1">#location = [voxel[0],voxel[1],voxel[2]]</span>
        <span class="c1">#if len(voxel)&gt;3:</span>
          <span class="c1">#power = voxel[3]</span>
        <span class="c1">#else:</span>
          <span class="c1">#power = -1</span>
        <span class="c1">##point = point - centro</span>
        <span class="c1">#location = P.getI()*numpy.transpose(numpy.matrix(location))</span>
        <span class="c1">#location = centro + location</span>
        <span class="c1">#write_sequence[i] = [location[0],location[1],location[2],power]</span>


<div class="viewcode-block" id="GWLobject.addTubeWithVerticalLines"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addTubeWithVerticalLines">[docs]</a>  <span class="k">def</span> <span class="nf">addTubeWithVerticalLines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centro</span><span class="p">,</span> <span class="n">inner_radius</span><span class="p">,</span> <span class="n">outer_radius</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">PointDistance_r</span><span class="p">,</span> <span class="n">PointDistance_theta</span><span class="p">,</span> <span class="n">downwardWriting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zigzag</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># counter value used to determine the writing direction: 0=down-&gt;top 1=top-&gt;down</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">downwardWriting</span><span class="p">)</span>

    <span class="c1"># TODO: optimize with zigzag writing</span>
    <span class="k">for</span> <span class="n">radius</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">inner_radius</span><span class="p">,</span> <span class="n">outer_radius</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">outer_radius</span> <span class="o">-</span> <span class="n">inner_radius</span><span class="p">)</span><span class="o">/</span><span class="n">PointDistance_r</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">PointDistance_theta</span><span class="p">:</span>
        <span class="c1"># TODO: power argument could probably be passed through centro?</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centro</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">centro</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">centro</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">power</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">P</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">power</span><span class="p">)</span> <span class="c1"># Downward writing</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">P</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">power</span><span class="p">)</span> <span class="c1"># Upward writing</span>
        <span class="k">if</span> <span class="n">zigzag</span><span class="p">:</span> <span class="n">counter</span><span class="o">+=</span><span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">alphaStep</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PointDistance_theta</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">alphaStep</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
          <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">centro</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)),</span><span class="n">centro</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)),</span><span class="n">centro</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">power</span><span class="p">])</span>
          <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">P</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">P</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">power</span><span class="p">)</span> <span class="c1"># Downward writing</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLine</span><span class="p">(</span><span class="n">P</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">P</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">height</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">power</span><span class="p">)</span> <span class="c1"># Upward writing</span>
          <span class="k">if</span> <span class="n">zigzag</span><span class="p">:</span> <span class="n">counter</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.rotate"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.rotate">[docs]</a>  <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_point</span><span class="p">,</span> <span class="n">axis_direction</span><span class="p">,</span> <span class="n">angle_degrees</span><span class="p">):</span>
    <span class="c1">#print(&#39;@@@@@@@@@@@@@@@@@@@@@@&#39;)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">TransformationMatrix</span><span class="o">.</span><span class="n">rotationMatrix</span><span class="p">(</span><span class="n">axis_point</span><span class="p">,</span> <span class="n">axis_direction</span><span class="p">,</span> <span class="n">angle_degrees</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)):</span>
        <span class="c1">#print(&#39;@@@@@@@@@@@@@@@@@@@@@@&#39;)</span>
        <span class="n">write_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TransformationMatrix</span><span class="o">.</span><span class="n">applyTransformation</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">write_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span></div>

  <span class="c1"># TODO: Use better names/transformation system to implement translations</span>
<div class="viewcode-block" id="GWLobject.applyTransformationMatrix"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.applyTransformationMatrix">[docs]</a>  <span class="k">def</span> <span class="nf">applyTransformationMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">centro</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)):</span>
        <span class="n">voxel</span> <span class="o">=</span> <span class="n">write_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#print(voxel)</span>
        <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="n">voxel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">voxel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">voxel</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
          <span class="n">power</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1">#point = point - centro</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">location</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#numpy.array(numpy.transpose(M))[0]</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">centro</span> <span class="o">+</span> <span class="n">location</span>
        <span class="c1">#print((&#39;location=&#39;,location))</span>
        <span class="n">write_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">location</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">power</span><span class="p">]</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.addHorizontalGrating"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addHorizontalGrating">[docs]</a>  <span class="k">def</span> <span class="nf">addHorizontalGrating</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">LineNumber</span><span class="p">,</span> <span class="n">LineDistance</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P1</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance</span>
    <span class="n">P1_min</span> <span class="o">=</span> <span class="n">P1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">v</span>

    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">LineNumber</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">P1_min</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">LineDistance</span><span class="o">*</span><span class="n">v</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="p">(</span><span class="n">P2</span><span class="o">-</span><span class="n">P1</span><span class="p">)</span>
        <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span> <span class="ow">in</span> <span class="n">plist</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">])</span>
      <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="GWLobject.addZGrating"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addZGrating">[docs]</a>  <span class="k">def</span> <span class="nf">addZGrating</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">LineNumber</span><span class="p">,</span> <span class="n">LineDistance</span><span class="p">,</span> <span class="n">BottomToTop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">Zcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">zlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance</span>
    <span class="k">if</span> <span class="n">BottomToTop</span><span class="p">:</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Zcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Zcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Zcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Zcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber</span><span class="p">)</span>
    <span class="c1">#if LineNumber%2: #odd LineNumber</span>
      <span class="c1">#zlist = numpy.linspace(Zcenter-0.5*L, Zcenter+0.5*L, LineNumber)</span>
    <span class="c1">#else: #even LineNumber</span>
      <span class="c1">#zlist = numpy.arange(Zcenter-LineNumber/2*LineDistance, Zcenter+((LineNumber-1)/2+1)*LineDistance, LineDistance)</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zlist</span><span class="p">:</span>
      <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">]</span>
      <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">])</span>
      <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="GWLobject.addBlockCentroSize"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addBlockCentroSize">[docs]</a>  <span class="k">def</span> <span class="nf">addBlockCentroSize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">centro</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span><span class="o">=</span><span class="n">DEFAULT_VOXEL_WIDTH</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span><span class="o">=</span><span class="n">DEFAULT_VOXEL_HEIGHT</span><span class="p">,</span> <span class="n">BottomToTop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">centro</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centro</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">centro</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">size</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">centro</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">size</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">addBlockLowerUpper</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span><span class="p">,</span> <span class="n">BottomToTop</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span></div>

  <span class="c1">## TODO: API: Was it a good idea to specify the other blocks in terms of LineNumber* in the first place?</span>
<div class="viewcode-block" id="GWLobject.addBlockLowerUpper"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addBlockLowerUpper">[docs]</a>  <span class="k">def</span> <span class="nf">addBlockLowerUpper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span><span class="o">=</span><span class="n">DEFAULT_VOXEL_WIDTH</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span><span class="o">=</span><span class="n">DEFAULT_VOXEL_HEIGHT</span><span class="p">,</span> <span class="n">BottomToTop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="p">(</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span> <span class="o">=</span> <span class="n">fixLowerUpper</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span>
    <span class="c1">#print(lower)</span>
    <span class="c1">#print(upper)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">abs</span><span class="p">(</span><span class="n">upper</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">lower</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span>
    <span class="c1">#print(dim)</span>

    <span class="c1"># TODO: will fix later</span>
    <span class="c1">#self.addXblock(lower, upper, LineDistance_Horizontal=LineDistance_Horizontal, LineDistance_Vertical=LineDistance_Vertical, BottomToTop=BottomToTop)</span>

    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
      <span class="k">elif</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;Y&#39;</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1">#dim[2]&gt;=dim[0] and dim[2]&gt;=dim[1]:</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>

    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">addXblock</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span><span class="o">=</span><span class="n">LineDistance_Horizontal</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span><span class="o">=</span><span class="n">LineDistance_Vertical</span><span class="p">,</span> <span class="n">BottomToTop</span><span class="o">=</span><span class="n">BottomToTop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">addYblock</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span><span class="o">=</span><span class="n">LineDistance_Horizontal</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span><span class="o">=</span><span class="n">LineDistance_Vertical</span><span class="p">,</span> <span class="n">BottomToTop</span><span class="o">=</span><span class="n">BottomToTop</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">addZblock</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">LineDistance_X</span><span class="o">=</span><span class="n">LineDistance_Horizontal</span><span class="p">,</span> <span class="n">LineDistance_Y</span><span class="o">=</span><span class="n">LineDistance_Horizontal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: Invalid direction. Should be &#39;X&#39;,&#39;Y&#39; or &#39;Z&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.addXblock"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addXblock">[docs]</a>  <span class="k">def</span> <span class="nf">addXblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">LineNumber_Horizontal</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_WIDTH</span><span class="p">,</span> <span class="n">LineNumber_Vertical</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_HEIGHT</span><span class="p">,</span> <span class="n">BottomToTop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

    <span class="c1"># TODO: Should use calculateNvoxelsAndInterVoxelDistance()? And overlap? -&gt; Other block functions should require overlap/linenumber args?</span>
    <span class="k">if</span> <span class="n">LineNumber_Horizontal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">LineNumber_Horizontal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">LineDistance_Horizontal</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">LineNumber_Vertical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">LineNumber_Vertical</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">LineDistance_Vertical</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="n">Xcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Ycenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Zcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1">#print Zcenter</span>
    <span class="c1">#print LineNumber_Vertical</span>

    <span class="n">ylist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber_Horizontal</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance_Horizontal</span>
    <span class="n">ylist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Ycenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Ycenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Horizontal</span><span class="p">)</span>

    <span class="n">zlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber_Vertical</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance_Vertical</span>
    <span class="k">if</span> <span class="n">BottomToTop</span><span class="p">:</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Zcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Zcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Vertical</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Zcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Zcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Vertical</span><span class="p">)</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zlist</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ylist</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">])</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="GWLobject.addYblock"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addYblock">[docs]</a>  <span class="k">def</span> <span class="nf">addYblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">LineNumber_Horizontal</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LineDistance_Horizontal</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_WIDTH</span><span class="p">,</span> <span class="n">LineNumber_Vertical</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LineDistance_Vertical</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_HEIGHT</span><span class="p">,</span> <span class="n">BottomToTop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">LineNumber_Horizontal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">LineNumber_Horizontal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">LineDistance_Horizontal</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">LineNumber_Vertical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">LineNumber_Vertical</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">LineDistance_Vertical</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="n">Xcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Ycenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Zcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">xlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber_Horizontal</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance_Horizontal</span>
    <span class="n">xlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Xcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Xcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Horizontal</span><span class="p">)</span>

    <span class="n">zlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber_Vertical</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance_Vertical</span>
    <span class="k">if</span> <span class="n">BottomToTop</span><span class="p">:</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Zcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Zcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Vertical</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Zcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Zcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Vertical</span><span class="p">)</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zlist</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xlist</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">])</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span></div>

  <span class="c1"># TODO: API improvement: use P1,P2 to specify BottomToTop? Leave in BottomToTop? Pass just x, y or z coordinates instead of [x,y,z]? X,Y,Z functions should be more or less the same if possible.</span>
<div class="viewcode-block" id="GWLobject.addZblock"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addZblock">[docs]</a>  <span class="k">def</span> <span class="nf">addZblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">LineNumber_X</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LineDistance_X</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_WIDTH</span><span class="p">,</span> <span class="n">LineNumber_Y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">LineDistance_Y</span> <span class="o">=</span> <span class="n">DEFAULT_VOXEL_WIDTH</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">LineNumber_X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">LineNumber_X</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">LineDistance_X</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">LineNumber_Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">LineNumber_Y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">LineDistance_Y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="n">Xcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Ycenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">Zcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">xlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber_X</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance_X</span>
    <span class="n">xlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Xcenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Xcenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_X</span><span class="p">)</span>

    <span class="n">ylist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">LineNumber_Y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">LineDistance_Y</span>
    <span class="n">ylist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">Ycenter</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Ycenter</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">LineNumber_Y</span><span class="p">)</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">ylist</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xlist</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">counter</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">])</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span></div>

  <span class="c1"># TODO: Improve by just passing a min/max PointDistance and choosing the distance so that it gives a nice integer number of points to fit the desired circle arc?</span>
  <span class="c1"># TODO: different functions for this? func options?</span>
<div class="viewcode-block" id="GWLobject.addHorizontalCircle"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addHorizontalCircle">[docs]</a>  <span class="k">def</span> <span class="nf">addHorizontalCircle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">PointDistance_max</span><span class="p">,</span> <span class="n">startAngle</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">endAngle</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">closed_loop</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">PointDistance_max</span><span class="p">:</span>
      <span class="n">write_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">alphaStep_max</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PointDistance_max</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">))</span>
      <span class="n">angleRange</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">endAngle</span><span class="o">-</span><span class="n">startAngle</span><span class="p">)</span>
      <span class="n">Npoints_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span> <span class="n">angleRange</span><span class="o">/</span><span class="n">alphaStep_max</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">))</span>
      <span class="n">alphaStep</span> <span class="o">=</span> <span class="n">angleRange</span><span class="o">/</span><span class="p">(</span><span class="n">Npoints_min</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">closed_loop</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Npoints_min</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">Npoints_min</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">currentAngle</span> <span class="o">=</span> <span class="n">startAngle</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">alphaStep</span>
        <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">power</span> <span class="ow">and</span> <span class="n">power</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">:</span>
          <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">currentAngle</span><span class="p">),</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">currentAngle</span><span class="p">),</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">power</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">currentAngle</span><span class="p">),</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">currentAngle</span><span class="p">),</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">write_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.addHorizontalDisk"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addHorizontalDisk">[docs]</a>  <span class="k">def</span> <span class="nf">addHorizontalDisk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">PointDistance</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">radius</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">PointDistance</span><span class="p">))</span>
    <span class="c1">#print((&#39;N = &#39;,N))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">PointDistance</span><span class="p">)</span>
        <span class="c1">##print center</span>
        <span class="c1">#self.GWL_voxels.append([center])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">radius</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">power</span><span class="p">,</span> <span class="n">PointDistance</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.addSphere"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addSphere">[docs]</a>  <span class="k">def</span> <span class="nf">addSphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="n">solid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

    <span class="n">PointDistance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">HorizontalPointDistance</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="n">VerticalPointDistance</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1">#print PointDistance</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">center</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">alphaStep</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PointDistance</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">radius</span><span class="p">))</span>
      <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">alphaStep</span><span class="p">)</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1">#print((&#39;i = &#39;,i,&#39; N = &#39;,N))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">radius</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="n">zlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

      <span class="c1"># symetrify list</span>
      <span class="n">zlist</span> <span class="o">=</span> <span class="n">zlist</span> <span class="o">+</span> <span class="p">[</span> <span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">zlist</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">zlist</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>

      <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">zlist</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">local_radius</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="nb">pow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1">#print((&#39;local_radius 1 = &#39;,local_radius))</span>
        <span class="c1">#local_radius = radius*numpy.sin(i*numpy.pi/float(N))</span>
        <span class="c1">#print((&#39;local_radius 2 = &#39;,local_radius))</span>
        <span class="k">if</span> <span class="n">solid</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">],</span> <span class="n">local_radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">z</span><span class="p">],</span> <span class="n">local_radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span></div>

    <span class="c1">#N = int(radius/float(VerticalPointDistance))</span>
    <span class="c1">#for i in range(-N,N+1):</span>
      <span class="c1">#z = i*radius/float(N)</span>
      <span class="c1">#local_radius = numpy.sqrt(pow(radius,2)-pow(z,2))</span>
      <span class="c1">##print &#39;local_radius = &#39;, local_radius</span>
      <span class="c1">#if solid:</span>
        <span class="c1">#self.addHorizontalDisk([center[0],center[1],center[2]+z], local_radius, power, HorizontalPointDistance)</span>
      <span class="c1">#else:</span>
        <span class="c1">#self.addHorizontalCircle([center[0],center[1],center[2]+z], local_radius, power, HorizontalPointDistance)</span>

<div class="viewcode-block" id="GWLobject.startNewVoxelSequence"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.startNewVoxelSequence">[docs]</a>  <span class="k">def</span> <span class="nf">startNewVoxelSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Starts a new voxel sequence, i.e. &quot;adds a Write command&quot; if you already had a &quot;voxel sequence&quot; before it when creating the .gwl file.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span>
    <span class="k">return</span></div>

  <span class="c1"># Completely disabling deprecated function, but leaving warning syntax as example.</span>
  <span class="c1">#def addWrite(self):</span>
    <span class="c1">#&#39;&#39;&#39;</span>
    <span class="c1">#DEPRECATED: Replaced by :py:func:`startNewVoxelSequence`.</span>
    <span class="c1">#&#39;&#39;&#39;</span>
    <span class="c1">#warnings.warn(&#39;DEPRECATED: addWrite() has been replaced by startNewVoxelSequence().&#39;, DeprecationWarning)</span>
    <span class="c1">#raise</span>
    <span class="c1">#return</span>

<div class="viewcode-block" id="GWLobject.addVoxel"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.addVoxel">[docs]</a>  <span class="k">def</span> <span class="nf">addVoxel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voxel</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Adds a voxel to the last &quot;writing sequence&quot;. If there is none, a new one will be created.</span>
<span class="sd">    Equivalent to adding a line of the form &quot;x y z [power]&quot; in your .gwl file.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">voxel</span><span class="p">])</span>

    <span class="c1"># update min/max values</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PositionMaximum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.readSubstitutes"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.readSubstitutes">[docs]</a>  <span class="k">def</span> <span class="nf">readSubstitutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subsFile</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Reading substitution pairs from &#39;</span><span class="o">+</span><span class="n">subsFile</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">path_substitutes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">subsFile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
          <span class="n">t</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">((</span><span class="n">old</span><span class="o">+</span><span class="s1">&#39; -&gt; &#39;</span><span class="o">+</span><span class="n">new</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path_substitutes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">))</span>
    <span class="c1">#TODO: reimplement nice exception system</span>
    <span class="c1">#except IOError as (errno, strerror):</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="c1">#print &quot;I/O error({0}): {1}&quot;.format(errno, strerror)</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Failed to open </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subsFile</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
      <span class="k">raise</span>
      <span class="c1"># raise Exception(msg)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_substitutes</span></div>

<div class="viewcode-block" id="GWLobject.readGWL"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.readGWL">[docs]</a>  <span class="k">def</span> <span class="nf">readGWL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="n">Nvoxels</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_object</span><span class="p">:</span>
            <span class="c1">#print line</span>
            <span class="n">line_stripped</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1"># TODO: handle comments and other commands</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_stripped</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">line_stripped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;%&#39;</span><span class="p">:</span>
              <span class="c1">#print &#39;pre-split: &#39;, line_stripped</span>
              <span class="c1">#cmd = re.split(&#39;[^a-zA-Z0-9_+-.]+&#39;,line_stripped)</span>
              <span class="c1">#cmd = re.split(&#39;[^a-zA-Z0-9_+-.:\\/]+&#39;,line_stripped)</span>
              <span class="c1">#cmd = re.split(&#39;[ \t]&#39;,line_stripped)</span>
              <span class="n">cmd</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">line_stripped</span><span class="p">)</span>
              <span class="c1">#cmd = [ i.lower() for i in cmd ]</span>
              <span class="c1">#print &#39;post-split: &#39;, cmd</span>
              <span class="n">stopRepeat</span> <span class="o">=</span> <span class="kc">True</span>
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Repeat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[a-zA-Z]&quot;</span><span class="p">,</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;-999&#39;</span> <span class="ow">or</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;-999.000&#39;</span><span class="p">:</span>
                  <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;-999&#39;</span> <span class="ow">or</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;-999.000&#39;</span><span class="p">:</span>
                    <span class="c1">#print(&#39;match 999&#39;)</span>
                    <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;-999&#39;</span> <span class="ow">or</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;-999.000&#39;</span><span class="p">:</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span>
                      <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[]</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">+</span> <span class="mf">1e-3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">DwellTime</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">maxDistanceBetweenLines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ScanSpeed</span><span class="o">*</span><span class="mf">1e-3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">DwellTime</span>
                  <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;other match&#39;)</span>
                    <span class="k">if</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;write&#39;</span><span class="p">:</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span>
                      <span class="n">write_sequence</span> <span class="o">=</span> <span class="p">[]</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">+</span> <span class="mf">1e-3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">DwellTime</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">maxDistanceBetweenLines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ScanSpeed</span><span class="o">*</span><span class="mf">1e-3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">DwellTime</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;include&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;line_stripped = &#39;</span> <span class="o">+</span> <span class="n">line_stripped</span><span class="p">))</span>
                      <span class="n">file_to_include</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">line_stripped</span><span class="p">,</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;including file_to_include = &#39;</span> <span class="o">+</span> <span class="n">file_to_include</span><span class="p">))</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fixing file separators&#39;</span><span class="p">)</span>
                      <span class="n">file_to_include</span> <span class="o">=</span> <span class="n">file_to_include</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
                      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;including file_to_include = &#39;</span> <span class="o">+</span> <span class="n">file_to_include</span><span class="p">))</span>
                      <span class="n">file_to_include_fullpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_to_include</span><span class="p">)))</span>
                      <span class="nb">print</span><span class="p">(</span><span class="n">file_to_include_fullpath</span><span class="p">)</span>
                      <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file_to_include_fullpath</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: File not found. Attempting path substitutions&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_substitutes</span><span class="p">:</span>
                          <span class="n">file_to_try</span> <span class="o">=</span> <span class="n">file_to_include</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
                          <span class="c1">#print(&#39;file_to_try = &#39;,file_to_try)</span>
                          <span class="c1">#print(&#39;filename = &#39;,filename)</span>
                          <span class="c1">#print(&#39;os.path.dirname(filename) = &#39;,os.path.dirname(filename))</span>
                          <span class="n">file_to_try</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_to_try</span><span class="p">)))</span>
                          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;old = &#39;</span> <span class="o">+</span> <span class="n">old</span><span class="p">))</span>
                            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;new = &#39;</span> <span class="o">+</span> <span class="n">new</span><span class="p">))</span>
                            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;file_to_include = &#39;</span> <span class="o">+</span> <span class="n">file_to_include</span><span class="p">))</span>
                            <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;filename = &#39;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">))</span>
                          <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Trying file_to_try = &#39;</span> <span class="o">+</span> <span class="n">file_to_try</span><span class="p">))</span>
                          <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file_to_try</span><span class="p">):</span>
                            <span class="n">file_to_include_fullpath</span> <span class="o">=</span> <span class="n">file_to_try</span>
                            <span class="k">break</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">readGWL</span><span class="p">(</span><span class="n">file_to_include_fullpath</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;movestagex&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Moving X by &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                      <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stage_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;movestagey&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Moving Y by &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                      <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stage_position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage_position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;addxoffset&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding X offset of &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;addyoffset&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding Y offset of &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;addzoffset&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding Z offset of &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;xoffset&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting X offset to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;yoffset&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting Y offset to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;zoffset&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting Z offset to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;linenumber&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting LineNumber to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">LineNumber</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;linedistance&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting LineDistance to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">LineDistance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;powerscaling&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting PowerScaling to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">PowerScaling</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;laserpower&#39;</span><span class="p">:</span>
                      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting LaserPower to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">LaserPower</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;scanspeed&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting ScanSpeed to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ScanSpeed</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">except</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Failed to do something...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1"># .. todo:: check var type before and later implement a real parser...</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;repeat&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Repeating next command &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; times.&#39;</span><span class="p">)</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">Repeat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="n">stopRepeat</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1">#elif cmd[0].lower()==&#39;defocusfactor&#39;:</span>
                      <span class="c1">#print &#39;defocusfactor&#39;</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;findinterfaceat&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting FindInterfaceAt to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">FindInterfaceAt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">0</span><span class="p">]</span>
                      <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;dwelltime&#39;</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting DwellTime to &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">DwellTime</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


                    <span class="k">else</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;UNKNOWN COMMAND: &#39;</span><span class="o">+</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                      <span class="c1">#sys.exit(-1)</span>
                <span class="k">else</span><span class="p">:</span>
                  <span class="c1">#print &#39;=&gt;VOXEL&#39;</span>
                  <span class="n">voxel</span> <span class="o">=</span> <span class="p">[]</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmd</span><span class="p">)):</span>
                    <span class="n">piezo_position</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">piezo_position</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">piezo_position</span><span class="o">&gt;</span><span class="mi">300</span><span class="p">:</span>
                      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_of_range</span><span class="p">:</span>
                        <span class="n">errmsg</span> <span class="o">=</span> <span class="s1">&#39;ERROR: voxel out of range! len(voxel) = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; piezo_position = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">piezo_position</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; i = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s1">&#39;piezo_position = float(cmd[i]) + self.voxel_offset[i]&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">piezo_position</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">+</span><span class="s1">&#39; + &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voxel_offset</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s1">&#39;filename = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s1">&#39;cmd = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">errmsg</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">out_of_range</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">voxel</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">piezo_position</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage_position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">FindInterfaceAt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
                  <span class="c1">#voxel = [ float(i) for i in cmd ]</span>
                  <span class="p">(</span><span class="n">last_voxel</span><span class="p">,</span><span class="n">found_last_voxel</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLastVoxel</span><span class="p">()</span>
                  <span class="n">write_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span>
                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
                      <span class="n">a</span> <span class="o">=</span> <span class="n">write_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                      <span class="n">b</span> <span class="o">=</span> <span class="n">write_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                      <span class="n">newDist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                      <span class="n">newTime</span> <span class="o">=</span> <span class="n">newDist</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ScanSpeed</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">+</span> <span class="n">newTime</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">writingDistanceInMum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writingDistanceInMum</span> <span class="o">+</span> <span class="n">newDist</span>
                  <span class="k">elif</span> <span class="n">found_last_voxel</span><span class="p">:</span>
                      <span class="n">a</span> <span class="o">=</span> <span class="n">last_voxel</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                      <span class="n">b</span> <span class="o">=</span> <span class="n">write_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                      <span class="n">newDist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                      <span class="n">newTime</span> <span class="o">=</span> <span class="n">newDist</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ScanSpeed</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span> <span class="o">+</span> <span class="n">newTime</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">writingDistanceInMum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">writingDistanceInMum</span> <span class="o">+</span> <span class="n">newDist</span>

                  <span class="n">Nvoxels</span> <span class="o">=</span> <span class="n">Nvoxels</span> <span class="o">+</span> <span class="mi">1</span>

              <span class="c1"># reset repeat</span>
              <span class="k">if</span> <span class="n">stopRepeat</span><span class="p">:</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">Repeat</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">UnicodeDecodeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
          <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> 
    <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">xxx_todo_changeme</span><span class="p">:</span>
      <span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme</span><span class="o">.</span><span class="n">args</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I/O error(</span><span class="si">{0}</span><span class="s2">): </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">))</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to open &#39;</span><span class="o">+</span><span class="n">filename</span><span class="p">)</span>
      <span class="k">raise</span>

    <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Nvoxels = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nvoxels</span><span class="p">)))</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;self.writingTimeInSeconds = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span><span class="p">)))</span>
      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;self.writingTimeInMinutes = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span><span class="o">/</span><span class="mf">60.</span><span class="p">)))</span>
      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;self.writingTimeInHours = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writingTimeInSeconds</span><span class="o">/</span><span class="p">(</span><span class="mf">60.</span><span class="o">*</span><span class="mf">60.</span><span class="p">))))</span>
      <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;self.writingDistanceInMum = &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">writingDistanceInMum</span><span class="p">)))</span>
    <span class="c1">#return GWL_voxels</span>
    <span class="k">return</span></div>

<div class="viewcode-block" id="GWLobject.writeGWL"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.writeGWL">[docs]</a>  <span class="k">def</span> <span class="nf">writeGWL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">writingOffset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">bool_LaserPowerCommand</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Writes out the GWL file.</span>
<span class="sd">    This function is old and does not use the new power compensation attributes.</span>
<span class="sd">    </span>
<span class="sd">    See also: :py:func:`writeGWLWithPowerCompensation`</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;GWLobject.writeGWL&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Writing GWL to &#39;</span><span class="o">+</span><span class="n">filename</span><span class="p">))</span>

    <span class="n">lastPower</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">voxel</span> <span class="ow">in</span> <span class="n">write_sequence</span><span class="p">:</span>

          <span class="c1"># TODO: add options to enable/disable warnings for coords/power out of range or invalid voxel sizes</span>
          <span class="c1"># TODO: Make voxels always have 4 coordinates and set 4th to None if undesired? Should make things easier... (but take up more RAM)</span>
          <span class="c1"># TODO: rewrite this with single-line write commands instead of complex for loops... (unless we expect voxels with arbitrary lengths)</span>

          <span class="c1">#lastPower = writeVoxel(f, voxel, laser_power_at_z0, K, interfaceAt, bool_LaserPowerCommand, lastPower)</span>

          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">writingOffset</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="kc">None</span>

          <span class="k">if</span> <span class="n">bool_LaserPowerCommand</span> <span class="ow">and</span> <span class="n">power</span> <span class="o">!=</span> <span class="n">lastPower</span><span class="p">:</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;LaserPower </span><span class="si">%.3f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">power</span><span class="p">)</span>

          <span class="c1">## only for standard voxels (length 3 or 4)</span>
          <span class="c1">#if len(voxel)&gt;4:</span>
            <span class="c1">#print(&#39;ERROR: voxel with more than 4 parameters&#39;,file=stderr)</span>
            <span class="c1">#sys.exit(-1)</span>
          <span class="c1">#print(voxel)</span>
          <span class="c1">#print(range(len(voxel)))</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">writingOffset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span> <span class="c1">#coordinates</span>
              <span class="c1">#print(&#39;COORD&#39;)</span>
              <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="nb">str</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#power</span>
              <span class="c1">#print(&#39;POWER&#39;)</span>
              <span class="k">if</span> <span class="ow">not</span> <span class="n">bool_LaserPowerCommand</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">value</span> <span class="ow">and</span> <span class="n">value</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">:</span>
                  <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="nb">str</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
            <span class="c1"># add tab or line ending</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">voxel</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
              <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

          <span class="n">lastPower</span> <span class="o">=</span> <span class="n">power</span>

          <span class="c1">## general method for voxels of any length</span>
          <span class="c1">#for i in range(len(voxel)):</span>
            <span class="c1">#file_object.write( str( &quot;%.3f&quot; % (voxel[i] + writingOffset[i]) ) )</span>
            <span class="c1">#if i&lt;len(voxel)-1:</span>
              <span class="c1">#file_object.write(&#39;\t&#39;)</span>
            <span class="c1">#else:</span>
              <span class="c1">#file_object.write(&#39;\n&#39;)</span>

        <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Write</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="GWLobject.writeGWLWithPowerCompensation"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.GWLobject.writeGWLWithPowerCompensation">[docs]</a>  <span class="k">def</span> <span class="nf">writeGWLWithPowerCompensation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Writes out the GWL file, but using the GWLobject&#39;s attributes related to power compensation.</span>
<span class="sd">    </span>
<span class="sd">    .. note:: The latest Nanowrite software supports new commands allowing easy changes to the power compensation (power slope, etc).</span>
<span class="sd">              Please test and use those instead. If they work, it will make functions like this one mostly obsolete.</span>
<span class="sd">              The new GWL commands are: psPowerProfile, psLoadPowerProfiles, psPowerSlope</span>
<span class="sd">              </span>
<span class="sd">              Example::</span>
<span class="sd">              </span>
<span class="sd">                FindInterfaceAt 0.5</span>
<span class="sd">                PowerScaling 1.5</span>
<span class="sd">                LaserPower 3</span>
<span class="sd">                psPowerSlope 2</span>
<span class="sd">                0 0 0</span>
<span class="sd">                0 0 10</span>
<span class="sd">                Write</span>

<span class="sd">              This should be equivalent to the old::</span>

<span class="sd">                0 0 0 3</span>
<span class="sd">                0 0 10 90.0 % = 3 * 1 * (1 + 2*(z-0.5))*1.5</span>
<span class="sd">                Write</span>

<span class="sd">              The formula used is::</span>
<span class="sd">              </span>
<span class="sd">                LPeff = LaserPower * eta(|nu|) * mu(z)</span>
<span class="sd">                </span>
<span class="sd">              with::</span>
<span class="sd">              </span>
<span class="sd">                eta(|nu|) = 1</span>
<span class="sd">                mu(z) = (1 + psPowerSlope*(z-FindInterfaceAt))*PowerScaling</span>

<span class="sd">    .. todo:: write power coords if they exist, even if self.write_power is False. This will allow local power specifications, even if Z-based power compensation is used. Maybe add another attribute/function to write voxels without power. relative powers could also be used to combine them with power compensation. (although the PowerScaling command exists exactly for this purpose, so no real need for that)</span>
<span class="sd">    .. todo:: X/Y-based power compensation? Not really necessary... But if the *User* wants flexibility, his own power compensation function (now that&#39;s more useful), etc...</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;GWLobject.writeGWLWithPowerCompensation&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">((</span><span class="s1">&#39;Writing GWL to &#39;</span><span class="o">+</span><span class="n">filename</span><span class="p">))</span>
    
    <span class="n">last_power</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_object</span><span class="p">:</span>

      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_line_order_on_write</span><span class="p">:</span>
        <span class="n">GWL_voxels_iterator</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">GWL_voxels_iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GWL_voxels</span>
         
      <span class="k">for</span> <span class="n">write_sequence</span> <span class="ow">in</span> <span class="n">GWL_voxels_iterator</span><span class="p">:</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_voxel_order_per_line_on_write</span><span class="p">:</span>
          <span class="n">write_sequence_iterator</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">write_sequence</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">write_sequence_iterator</span> <span class="o">=</span> <span class="n">write_sequence</span>

        <span class="k">for</span> <span class="n">voxel</span> <span class="ow">in</span> <span class="n">write_sequence_iterator</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">y</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">voxel</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_lower_to_origin</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">PositionMinimum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
          
          <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_power</span><span class="p">:</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPower</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">PC_bool_LaserPowerCommand</span><span class="p">:</span>
              <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">power</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="k">if</span> <span class="n">power</span> <span class="o">!=</span> <span class="n">last_power</span><span class="p">:</span>
                <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;LaserPower </span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">power</span><span class="p">))</span>
              <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\t</span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
          
            <span class="n">last_power</span> <span class="o">=</span> <span class="n">power</span>

        <span class="n">file_object</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Write</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span></div></div>

<div class="viewcode-block" id="test1"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.test1">[docs]</a><span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
  <span class="c1">#GWL_obj = GWLobject()</span>
  <span class="c1">#GWL_obj.readGWL(sys.argv[1])</span>
  <span class="c1">##print GWL_obj.GWL_voxels</span>
  <span class="c1">#GWL_obj.writeGWL(&#39;copy.gwl&#39;)</span>

  <span class="n">GWL_obj</span> <span class="o">=</span> <span class="n">GWLobject</span><span class="p">()</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addXblock</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.050</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.100</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addXblock</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.5</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.050</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.100</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addXblock</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.75</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.75</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.050</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.100</span><span class="p">)</span>
  <span class="n">z</span> <span class="o">=</span> <span class="mf">7.1038825</span><span class="p">;</span> <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addXblock</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">z</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mf">0.050</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.100</span><span class="p">)</span>

  <span class="n">power</span> <span class="o">=</span> <span class="mi">75</span>

  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">HorizontalPointDistance</span> <span class="o">=</span> <span class="mf">0.050</span>
  <span class="n">VerticalPointDistance</span> <span class="o">=</span> <span class="mf">0.100</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="c1">#print &#39;addHorizontalCircle&#39;</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="c1">#print &#39;addHorizontalDisk&#39;</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="c1">#print &#39;addSphere non-solid&#39;</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="c1">#print &#39;addSphere solid&#39;</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="n">HorizontalPointDistance</span> <span class="o">=</span> <span class="mf">0.100</span>
  <span class="n">VerticalPointDistance</span> <span class="o">=</span> <span class="mf">0.200</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="n">HorizontalPointDistance</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">VerticalPointDistance</span> <span class="o">=</span> <span class="mf">0.5</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="n">HorizontalPointDistance</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">VerticalPointDistance</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="n">HorizontalPointDistance</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">VerticalPointDistance</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;300&#39;</span><span class="p">)</span>
  <span class="n">HorizontalPointDistance</span> <span class="o">=</span> <span class="mf">0.050</span>
  <span class="n">VerticalPointDistance</span> <span class="o">=</span> <span class="mf">0.100</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="mf">0.300</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;350&#39;</span><span class="p">)</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">70</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="mf">0.350</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;400&#39;</span><span class="p">)</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="mf">0.400</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalCircle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addHorizontalDisk</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">11</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addSphere</span><span class="p">([</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">22</span><span class="p">],</span> <span class="n">radius</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">HorizontalPointDistance</span><span class="p">,</span> <span class="n">VerticalPointDistance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>


  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">writeGWL</span><span class="p">(</span><span class="s1">&#39;xblock.gwl&#39;</span><span class="p">)</span>

  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addXblock</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.75</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.75</span><span class="p">],</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.050</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mf">0.100</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">addYblock</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">2.75</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mf">2.75</span><span class="p">],</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.050</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mf">0.100</span><span class="p">)</span>
  <span class="n">GWL_obj</span><span class="o">.</span><span class="n">writeGWL</span><span class="p">(</span><span class="s1">&#39;xblock2.gwl&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="test2"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.test2">[docs]</a><span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>
  <span class="n">obj</span> <span class="o">=</span> <span class="n">GWLobject</span><span class="p">()</span>

  <span class="n">N</span><span class="o">=</span><span class="mi">5</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">addVoxel</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">startNewVoxelSequence</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">addVoxel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">startNewVoxelSequence</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">addVoxel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">startNewVoxelSequence</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">addVoxel</span><span class="p">([</span><span class="o">-</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">startNewVoxelSequence</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">addVoxel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">startNewVoxelSequence</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">addVoxel</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">i</span><span class="p">])</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">startNewVoxelSequence</span><span class="p">()</span>

  <span class="n">obj</span><span class="o">.</span><span class="n">set_lower_to_origin</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">write_power</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">PC_laser_power_at_z0</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">PC_slope</span> <span class="o">=</span> <span class="mf">0.1</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">PC_interfaceAt</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">PC_float_height</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">PC_bool_InverseWriting</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">PC_bool_LaserPowerCommand</span> <span class="o">=</span> <span class="kc">False</span>

  
  <span class="n">obj</span><span class="o">.</span><span class="n">writeGWLWithPowerCompensation</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">(),</span> <span class="s1">&#39;test2.gwl&#39;</span><span class="p">))</span>
  <span class="k">return</span></div>

<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../GWL.html#GWL.GWL_parser.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
  <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
  <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;infile&#39;</span><span class="p">)</span>
  <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-W&#39;</span><span class="p">,</span> <span class="s1">&#39;--just-warn&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Continue in case of warnings. (The default is to raise it as an error.)&#39;</span><span class="p">)</span>
  <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="s1">&#39;--verbose&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;verbosity&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;verbosity level&#39;</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  
  <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">just_warn</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">)</span>
  
  <span class="n">obj</span> <span class="o">=</span> <span class="n">GWLobject</span><span class="p">()</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">readGWL</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">infile</span><span class="p">)</span>

  <span class="k">return</span> <span class="mi">0</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
  <span class="c1"># .. todo:: Add tests to test suite</span>
  <span class="c1"># test1()</span>
  <span class="c1"># test2()</span>
  <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">script_inception_public  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, Mike Taverne.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>